#![allow(non_snake_case)]

#![allow(unused_mut)]




// particular type of state for testing
#[derive(Clone)]
struct State2 {
    a:f64,
    b:f64,
}

// Decision-making as described in paper "Predictive Heuristics for Decision-Making in Real-World Environments" page 7
pub fn main() {
    
    let mut goals:Vec<PlGoal> = Vec::new();
    goals.push(PlGoal{
        deadline:None,
        priority:1.0,
        id:1,
        timeOf:0.0,
    });
    
    goals.push(PlGoal{
        deadline:Some(12.0),
        priority:0.9,
        id:2,
        timeOf:12.0,
    });
    
    
        
    // function used to check if a goal was archived with a state
    let mut checkArchived:Box<CheckArchived<State2>> = Box::new(T{});
    
    
    
    let mut predictorStats = PlPredictorStats {
        nPos:1,
        n:1,
    };
    
    let mut currentState:State2 = State2{a:2.0,b:0.0};
    
    for iTime in 0..10 { // iterate over systemtime
        ///////////////
        // search for best state which has to be realized
        //
        // done by searching for the highest expectation
        
        let mut highestStateUtility:f64 = f64::MIN;
        
        
        let mut maxH:f64 = 10.0; // maximal horizon
        
        
        
        
        // proposed state with action (which leads to state)
        let mut proposedStateWAct:Vec<StateWithAction<State2>> = Vec::new();
        
        // TODO< let states get generated by predictor >
        
        // lookahead 1
        for iLookahead in 1..4 {
            proposedStateWAct.push(StateWithAction{state:State2{a:currentState.a+0.0,b:currentState.b+0.0},action:"^nop".to_string(),});
            proposedStateWAct.push(StateWithAction{state:State2{a:currentState.a+(iLookahead as f64)*1.0,b:currentState.b+0.0},action:"^r".to_string(),});
            proposedStateWAct.push(StateWithAction{state:State2{a:currentState.a    ,b:currentState.b+(iLookahead as f64)*1.0},action:"^d".to_string(),});
            proposedStateWAct.push(StateWithAction{state:State2{a:currentState.a    ,b:currentState.b-(iLookahead as f64)*1.0},action:"^u".to_string(),});
            proposedStateWAct.push(StateWithAction{state:State2{a:currentState.a-(iLookahead as f64)*1.0,b:currentState.b+0.0},action:"^l".to_string(),});            
        }

        
        
        let mut decisionLog:String = "".to_string(); // used to log decision process
        
        let mut bestStateWAct:Option<StateWithAction<State2>> = None; // selected state with action
        
        for iProposedStateWAct in &proposedStateWAct {
            
            let mut sum:f64 = 0.0;
            
            for iGoal in &goals { // compute archived*utility for each goal
                
                //let timeOf = iTime as f64; // 4.0
                
                
                let urgency:f64 = if iGoal.deadline.is_some() {
                    let horizon:f64 = iGoal.deadline.unwrap() - iGoal.timeOf;
                    horizon / maxH
                }
                else {
                    1.0 // else take default
                };
                
                let utility:f64 = iGoal.priority * urgency;
                
                
                decisionLog += &format!("goal.utility= {}\n", utility);
                
                let wasArchived:bool = checkArchived.check(&iGoal, &iProposedStateWAct); // was goal archived?
                let archived:f64 = convBoolToNP(wasArchived);
                sum += (archived * utility);
            }
            
            let predictor_confidence = (predictorStats.n as f64) / ((predictorStats.n as f64) + 1.0); // compute by Pei Wang's formula
            let predictor_successrate = (predictorStats.nPos as f64) / (predictorStats.n as f64); // compute by Pei Wang's formula
            let predictor_likelihood:f64 = predictor_confidence * (predictor_successrate - 0.5) + 0.5; // compute by Pei Wang's formula for expectation
            
            let expectedValue = predictor_likelihood * sum; // expected value for predictor
            
            decisionLog += &format!("sum= {}   expVal = {}\n", sum, expectedValue);
            
            if expectedValue > highestStateUtility {
                bestStateWAct = Some((*iProposedStateWAct).clone()); // store best option
                highestStateUtility = expectedValue;
            } 
        }
        
        // decrease to move closer to deadline
        for iGoal in &mut goals {
            iGoal.timeOf-=1.0;
        }
        
        // print best option
        match bestStateWAct {
            Some(bestStateWAct) => {
                println!("sel act {}", bestStateWAct.action);
                
                if bestStateWAct.action == "^l" {
                    currentState.a -= 1.0;
                }
                else if bestStateWAct.action == "^r" {
                    currentState.a += 1.0;
                }
                else if bestStateWAct.action == "^u" {
                    currentState.b -= 1.0;
                }
                else if bestStateWAct.action == "^d" {
                    currentState.b += 1.0;
                }
            }
            None => {}
        }
        
    }
}

struct T {}

impl CheckArchived<State2> for T {
    fn check(&self, goal:&PlGoal, stateWAction:&StateWithAction<State2>) -> bool {
        (stateWAction.state.a.powf(2.0)+stateWAction.state.b.powf(2.0)).sqrt() < 0.5
    }
}




// used to check if goal was archived
pub trait CheckArchived<T> {
    fn check(&self, goal:&PlGoal, state:&StateWithAction<T>) -> bool;
}


// planner goal
pub struct PlGoal {
    pub deadline:Option<f64>,
    pub priority:f64, // [0.0;1.0]
    pub id:i64, // id for unique identification
    pub timeOf:f64, // remaining time till deadline, is decreased after each tick
}

// planner predictor statistics
pub struct PlPredictorStats {
    pub nPos:i64, // how many positive predictions did the predictor make?
    pub n:i64, // how many predictions did the predictor make?
}


#[derive(Clone)]
pub struct StateWithAction<T> {
    pub state:T,
    pub action:String,
}

pub fn convBoolToNP(b:bool) -> f64 {
    if b {1.0} else {-1.0}
}